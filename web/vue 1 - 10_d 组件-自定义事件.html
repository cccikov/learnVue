<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>vue 组件</title>
    <script type="text/javascript" src="vue.js"></script>
</head>

<body>
    <!-- 自定义事件 -->
    <!-- 我们知道，父组件是使用 props 传递数据给子组件，但子组件怎么跟父组件通信呢？这个时候 Vue 的自定义事件系统就派得上用场了。 -->

    <!-- 每个 Vue 实例都实现了事件接口 (Events interface)，即：
    使用 $on(eventName) 监听事件
    使用 $emit(eventName) 触发事件 -->


    <!-- 父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。-->
    <!-- 不能用 $on 侦听子组件释放的事件，而必须在模板里直接用 v-on 绑定 -->


    <div id="counter-event-example">
        <p>{{ total }}</p>
        <button-counter v-on:increment="incrementTotal"></button-counter>
        <button-counter v-on:increment="incrementTotal"></button-counter>
        <button-counter></button-counter>
    </div>
    <script>
        Vue.component('button-counter', {
            template: '<button v-on:click="incrementCounter">{{ counter }}</button>',
            data: function() {
                return {
                    counter: 0,
                    name: "ccc",
                    age: 18
                }
            },
            methods: {
                incrementCounter: function() {
                    var data = {
                        counter: this.counter,
                        name: this.name,
                        age: this.age
                    }
                    this.counter += 1
                    this.$emit('increment', data); // 只是触发事件 increment , 可以传参所以就可以传递数据
                    // 子组件里面也不用特意去定义事件 increment
                }
            },
        });

        new Vue({
            el: '#counter-event-example',
            data: {
                total: 0
            },
            methods: {
                incrementTotal: function(data) { // 事件 increment的监听器
                    console.log(data); // 子组件传过来的数据
                    this.total += 1
                }
            }
        });

        // 上面用了三个子组件 , 其中前两都有监听事件increment , 第三个没有监听 , 父组件是可以完全不监听事件increment
        // 所以实际上子组件只是触发了increment事件 , 没有规定父组件一定要监听 , 所以是解耦的 。 就类似 , 我们在页面里面点击鼠标 , click事件就会触发 , 但是如果没有任何监听 , 就不了了之
    </script>





    <!-- 给组件绑定原生事件 -->
    <div id="app2">
        <tpl-b v-on:click="listener1"></tpl-b>
        <!-- 如果监听子组件上面的原生事件不加.native修饰符的话 , 会以为监听自定义事件 -->
        <tpl-b v-on:click.native="listener2"></tpl-b>
    </div>
    <script>
        Vue.component("tpl-b", {
            template: "<button v-bind:autoGoFn = 'fn1()'>按钮</button>",
            methods: {
                fn1: function() {
                    console.log("组件生成,自动执行函数执行");
                    var that = this;
                    var n = 10;
                    var m = 0;
                    var timer = setInterval(function() {
                        m++;
                        if (m >= n) {
                            clearInterval(timer);
                        }
                        that.$emit("click");
                    }, 1000);
                    return true;
                }
            }
        });

        new Vue({
            el: "#app2",
            methods: {
                listener1: function() {
                    console.log("触发自定义事件click");
                },
                listener2: function() {
                    console.log("触发原生click");
                }
            }
        });
    </script>

</body>